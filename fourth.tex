\documentclass{article}  
\usepackage{xcolor}  
\usepackage{listings}  
\usepackage{graphicx}
\usepackage[UTF8]{ctex}  
  
\lstset{  
    basicstyle=\ttfamily,  
    numbers=left,  
    numberstyle=\small,  
    frame=single,  
    showstringspaces=false,  
    language=Python  
}  
  
\begin{document}  
\title{\textcolor{red}{中国海洋大学}\\\textcolor{blue}{调试性能及分析工具，元编程，大杂烩，Pytorch入门}}
\author{袁东霖}  
\date{2024/9/6}  
\maketitle  
https://github.com/YAYaun/2024 \\
\section{\textcolor{blue}{终端彩色输出}}
\begin{itemize}
    \item  echo -e \verb+"\e[38;2;255;0;0mThis is red\e[0m"+  
    \\在终端打印红色
\end{itemize}
\section{\textcolor{blue}{python性能分析}}
\begin{lstlisting}
python -m memory_profiler example.py
\end{lstlisting}
\section{\textcolor{blue}{第三方日志系统}}
    \begin{itemize}
        \item dmesg 读取内核日志
        \item logger 将日志添加到系统日志
        \item lnav工具 对日志的结果进行大量过滤
    \end{itemize}
\section{\textcolor{blue}{调试器}}
    \begin{itemize}
        \item pdb Python的调试器
            \begin{itemize}
                \item l     显示当前行附近的11行或继续执行之前的显示
                \item s     执行当前行，并在第一个可能的地方停止
                \item n     继续执行直到当前函数的下一条语句或者return语句  
                \item b     设置断点
                \item p     对当前上下文的表达式求值并打印结果
                \item r     继续执行直到当前函数返回
                \item q     退出调试器
            \end{itemize}
    \end{itemize}
\section{\textcolor{blue}{计时}}
\begin{itemize}
    \item 计时分为用户时间和系统时间
        \begin{itemize}
            \item真实时间 Real - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I/O 或网络）；
            \item用户时间 User - CPU 执行用户代码所花费的时间；
            \item系统时间 Sys - CPU 执行系统内核代码所花费的时间。
        \end{itemize}
\end{itemize}
\section{\textcolor{blue}{调试工具}}
    \begin{itemize}
      \item pyflakes    对代码进行语法检查    
      \item mypy    对代码进行类型检查
      \item Python中的工具
        \begin{itemize}
            \item pylint和pep8 风格检查
            \item bandit 安全相关的检查
        \end{itemize}
    \end{itemize}
\section{\textcolor{blue}{性能调试}}
    \begin{itemize}
        \item cpu性能分析
            \begin{itemize}
                \item   追踪分析器和采样分析器 追踪分析器会记录程序的每一次函数调用，而采样分析器只会周期性的监测
                \item cProfile python的分析器
            \end{itemize}
    \end{itemize}
\section{\textcolor{blue}{make}}
构建系统，在空目录下使用会提醒你构建需要什么，如果构建的文件的所有依赖没有改变，构建文件不会呗重新构建
\section{\textcolor{blue}{Python函数调用关系}}
用pycallgraph相关库的功能
\section{\textcolor{blue}{依赖系统管理}}
    \begin{itemize}
        \item 主版本号.次版本号.补丁号 如果新的版本没有改变API，则补丁号递增，如果添加了API但向后兼容，则递增次版本号，API修改了但是不向后兼容，则主版本号递增 
    \end{itemize}
\section{\textcolor{blue}{通用监控}}
最流行的工具要数 htop, 了，它是 top 的改进版。htop 可以显示当前运行进程的多种统计信息。htop 有很多选项和快捷键，常见的有：<F6> 进程排序、 t 显示树状结构和 h 打开或折叠线程。 还可以留意一下 glances ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， dstat 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I/O、网络、 CPU 利用率、上下文切换等等；
\section{\textcolor{blue}{资源监控}}
\texttt{hyperline}进行基准测试    
\section{\textcolor{blue}{键位映射}}
\begin{itemize}
    \item 打开注册表输入regedit
    \item 打开keyboard Layout文件夹，新建二进制
    \item 打开，将对应键位码输入
\end{itemize}
\section{\textcolor{blue}{测试简介}}
多数的大型软件都有“测试套件”。您可能已经对测试的相关概念有所了解，但是我们觉得有些测试方法和测试术语还是应该再次提醒一下：\\
测试套件（Test suite）：所有测试的统称。\\
单元测试（Unit test）：一种“微型测试”，用于对某个封装的特性进行测试。\\
集成测试（Integration test）：一种“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能 协同 工作。\\
回归测试（Regression test）：一种实现特定模式的测试，用于保证之前引起问题的 bug 不会再次出现。\\
模拟（Mocking）: 使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会“模拟网络连接” 或 “模拟硬盘”。\\
\section{\textcolor{blue}{大杂烩}}
\begin{itemize}
    \item markdown 一个以简单代码形式编写的文本编辑器，可视化高，快捷键方便，适合代码做笔记
    \item 开机引导 如有系统启动盘，对u盘进行操作以后，开机前插入则会进入重装系统界面
\end{itemize}
\section{\textcolor{blue}{markdown}}
\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.2]{picturemd.png}
    \caption{Elliptic Paraboloid}
    \end{figure} 
\section{\textcolor{blue}{Pytorch入门}}
\begin{lstlisting}
from __future__ import print_function
import numpy as np
import torch    
tensor1 = torch.tensor([5.5, 3])
x = tensor1.new_ones(5, 3, dtype=torch.double) 
if torch.cuda.is_available():
    device = torch.device("cuda")        
    y = torch.ones_like(x, device=device) 
    x = x.to(device)                  
    z = x + y
    print(z)
    print(z.to("cpu", torch.double))    
\end{lstlisting}
\section{\textcolor{blue}{numpy数组转换成torch}}
\begin{lstlisting}
import numpy as np
a = np.ones(5)
b = torch.from_numpy(a)
\end{lstlisting}
\section{\textcolor{blue}{求最小值}}
\begin{lstlisting}
import numpy as np
import torch
x = torch.tensor(0.0, requires_grad=True)  
a = torch.tensor(1.0)
b = torch.tensor(-2.0)
c = torch.tensor(1.0)
optimizer = torch.optim.SGD(params=[x], lr=0.01)  
print(optimizer)
 
def f(x):
    result = a * torch.pow(x, 2) + b * x + c
    return (result)
 
for i in range(500):
    optimizer.zero_grad() 
    y = f(x)
    y.backward()  
    optimizer.step() 
print("y=", y.data, ";", "x=", x.data)
\end{lstlisting}
\section{\textcolor{blue}{识别图像模型}}
\begin{lstlisting}
import time
net.to(device)
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)

start = time.time()
for epoch in range(2):

    running_loss = 0.0
    for i, data in enumerate(trainloader, 0):
        inputs, labels = data
        inputs, labels = inputs.to(device), labels.to(device)
        optimizer.zero_grad()
        outputs = net(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
        if i % 2000 == 1999:
            print('[%d, %5d] loss: %.3f' % (epoch + 1, i+1, running_loss / 2000))
            running_loss = 0.0
print('Finished Training! Total cost time: ', time.time() - start)
\end{lstlisting}
\end{document} 